package com.compiler;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import com.compiler.*;

parser code {:
    public void debug_message(String message) {
        System.out.println("DEBUG: " + message);
    }
:}

// Declare the terminals (tokens)
terminal String IDENTIFIER, STRING_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Double REAL_LITERAL;
terminal Boolean BOOLEAN_LITERAL;
terminal VAR, IF, ELSE, WHILE, FOR, IN, ROUTINE, TYPE, RETURN, TRUE, FALSE, END, THEN, LOOP, PRINT, IS, AS, REVERSE; // Added REVERSE here
terminal INTEGER, REAL, BOOLEAN, RECORD, ARRAY, STRING;
terminal COLON, ASSIGN, SEMICOLON, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, DOT, COMMA;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, EQUAL, LESS, GREATER, AND, OR, XOR, MOD, NOT, GREATER_OR_EQUAL, LESS_OR_EQUAL, NOT_EQUAL, RANGE;


// Declare non-terminals (AST types)
non terminal Program program;
non terminal List<Statement> statement_list;
non terminal Statement statement;
non terminal Expression expression;
non terminal List<Expression> argument_list;
non terminal Expression relation;
non terminal Expression simple;
non terminal Expression factor;
non terminal Expression summand;
non terminal TypeDeclaration type_decl;
non terminal VariableDeclaration var_decl;
non terminal RoutineDeclaration routine_decl;
non terminal String type;  // Non-terminal for types
non terminal Reverse reverse_opt; // New non-terminal for optional reverse

// Specify the start symbol
start with program;

// Grammar Rules and Semantic Actions

program ::= statement_list:s {: RESULT = new Program(s); :};

statement_list ::= statement:s {: RESULT = new ArrayList<Statement>(); RESULT.add(s); :}
                 | statement_list:l statement:s {: l.add(s); RESULT = l; :};

// Updated statement rule to include SEMICOLON after END for control structures
statement ::= VAR IDENTIFIER:id COLON type:t ASSIGN expression:e SEMICOLON
                {: RESULT = new VarDecl(id, t, e); :}
            | VAR IDENTIFIER:id COLON type:t IS expression:e SEMICOLON
                {: RESULT = new VarDecl(id, t, e); :}
            | VAR IDENTIFIER:id ASSIGN expression:e SEMICOLON
                {: RESULT = new VarDecl(id, null, e); :}
            | VAR IDENTIFIER:id COLON type:t SEMICOLON
                {: RESULT = new VarDecl(id, t, null); :}
            | IDENTIFIER:id ASSIGN expression:e SEMICOLON
                {: RESULT = new Assignment(id, e); :}
            | TYPE IDENTIFIER:id IS type:t SEMICOLON
                {: RESULT = new TypeDecl(id, t); :}
            | ROUTINE IDENTIFIER:id LPAREN RPAREN IS statement_list:body END SEMICOLON
                {: RESULT = new RoutineDecl(id, body); :}
            | IF expression:e THEN statement_list:then_body ELSE statement_list:else_body END SEMICOLON
                {: RESULT = new IfStatement(e, then_body, else_body); :}
            | WHILE expression:e LOOP statement_list:body END SEMICOLON
                {: RESULT = new WhileStatement(e, body); :}
            | FOR IDENTIFIER:id IN reverse_opt:rev expression:start RANGE expression:end LOOP statement_list:body END SEMICOLON
                {: RESULT = new ForLoop(id, start, end, body, rev); :}
            | IDENTIFIER:id LPAREN argument_list:args RPAREN SEMICOLON
                {: RESULT = new RoutineCall(id, args); :}
            | RETURN expression:e SEMICOLON
                {: RESULT = new ReturnStatement(e); :}
            | PRINT LPAREN expression:e RPAREN SEMICOLON
                {: RESULT = new PrintStatement(e); :};

// Add support for reverse as an optional non-terminal
reverse_opt ::= REVERSE {: RESULT = new Reverse(true); :}
              | /* empty */ {: RESULT = new Reverse(false); :};


// Add support for basic types in the type rule
type ::= INTEGER {: RESULT = "integer"; :}
      | REAL {: RESULT = "real"; :}
      | BOOLEAN {: RESULT = "boolean"; :}
      | RECORD {: RESULT = "record"; :}
      | STRING {: RESULT = "string"; :}
      | ARRAY LBRACKET INTEGER_LITERAL RBRACKET type:t {: RESULT = "array[" + t + "]"; :};

// Expressions, including type casting and boolean literals
argument_list ::= expression:e {: RESULT = new ArrayList<Expression>(); RESULT.add(e); :}
                | argument_list:l COMMA expression:e {: l.add(e); RESULT = l; :};

expression ::= relation:e {: RESULT = e; :}
             | expression:e1 AND relation:e2 {: RESULT = new BinaryExpression(e1, "and", e2); :}
             | expression:e1 OR relation:e2 {: RESULT = new BinaryExpression(e1, "or", e2); :}
             | expression:e1 XOR relation:e2 {: RESULT = new BinaryExpression(e1, "xor", e2); :}
             | expression:e AS type:t {: RESULT = new TypeCastExpression(e, t); :}
             | TRUE {: RESULT = new LiteralExpression(true); :}
             | FALSE {: RESULT = new LiteralExpression(false); :};

relation ::= simple:e {: RESULT = e; :}
           | relation:e1 LESS simple:e2 {: RESULT = new BinaryExpression(e1, "<", e2); :}
           | relation:e1 GREATER simple:e2 {: RESULT = new BinaryExpression(e1, ">", e2); :}
           | relation:e1 EQUAL simple:e2 {: RESULT = new BinaryExpression(e1, "=", e2); :}
           | relation:e1 GREATER_OR_EQUAL simple:e2 {: RESULT = new BinaryExpression(e1, ">=", e2); :}
           | relation:e1 LESS_OR_EQUAL simple:e2 {: RESULT = new BinaryExpression(e1, "<=", e2); :}
           | relation:e1 NOT_EQUAL simple:e2 {: RESULT = new BinaryExpression(e1, "!=", e2); :};

simple ::= factor:e {: RESULT = e; :}
         | simple:e1 MULTIPLY factor:e2 {: RESULT = new BinaryExpression(e1, "*", e2); :}
         | simple:e1 DIVIDE factor:e2 {: RESULT = new BinaryExpression(e1, "/", e2); :}
         | simple:e1 MOD factor:e2 {: RESULT = new BinaryExpression(e1, "%", e2); :};

factor ::= MINUS summand:e 
             {: RESULT = new UnaryExpression("-", e); :}
         | NOT summand:e 
             {: RESULT = new UnaryExpression("not", e); :}
         | summand:e 
             {: RESULT = e; :}
         | factor:e1 PLUS summand:e2 
             {: RESULT = new BinaryExpression(e1, "+", e2); :}
         | factor:e1 MINUS summand:e2 
             {: RESULT = new BinaryExpression(e1, "-", e2); :};

summand ::= LPAREN expression:e RPAREN {: RESULT = e; :}
          | INTEGER_LITERAL:i {: RESULT = new LiteralExpression(i); :}
          | REAL_LITERAL:r {: RESULT = new LiteralExpression(r); :}
          | BOOLEAN_LITERAL:b {: RESULT = new LiteralExpression(b); :}
          | STRING_LITERAL:s {: RESULT = new LiteralExpression(s); :}
          | IDENTIFIER:id {: RESULT = new VariableExpression(id); :};
